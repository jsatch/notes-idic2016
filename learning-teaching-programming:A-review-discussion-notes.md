# Learning and Teaching Programming:A review discussion

Robins, J Rountree, N Rountree
2003

## Libros con estudios anteriores:
* Sackman, 1970 -> Intro
* Weinberg, 1971-> Intro
* Soloway & Spohrer, 1989 -> enfocado en el novice programmer
* Hoc, Green, Samurcay, Gillmore, 1990

## Estado del arte

### Computer knowledge vs Programming strategies

Davis (1993) distingue entre programming knowledge (como funciona un loop) y programming strategies (como el loop es utilizado y aplicado apropiadamente en un programa).

Widowski and Eyferth (1986) proponen diversos métodos como un programador lee un programa. Expertos leen programas convencionales utilizando una estrategia top-down y programas no convencionales en cortos runs (bottom-up). Novices lo leen los dos tipos de programa de la misma manera.

### Comprehension and generation

Estudios sobre comprehension y sobre generation. Comprenhension es cómo se demuestra cómo funciona un programa y generation donde los sujetos tiene que crear una parte o todo el programa para resolver un problema.

#### Comprehension
Brooks (1977, 1983): un problema es representado como valores y estructuras (dominio intermedio) y luego instancia en algoritmos y estructuras de datos (programming domain).
Programas es formar mapeos entre dominios.
Este proceso es top-down y hipothesis driven

#### Generation
Rist(1995)
El conocimiento esta estructurado en nodos  en la memoria interna (working, episodic y semantic) o externa que son mas la especificación del programa, notas anteriores o el programa en si mismo).
Un search cue inicia la busqueda del nodo y se obtiene de la memoria y este nodo da lugar a otros nodos (muchas veces con otros search cues relacionados). Un sistema lineado de nodos que llevan a un resultado (output) es un plan.
Expertos obtienen los planes de la memoria y luego los implementan de forma lineal mientras que novices tienen que crear los planes.
Rist denota que un proceso realista de diseño envuelve la interacción  entre la busqueda de la estrategia y el diseño oportunista, la creación y obtención de un plan dada las limitaciones de la working memory y la estructura de la especificación del programa.
habla de working memory “parsing-ginsarp” de Green, Bellamy & Parker (1987)

### Procedural vs Object Oriented
Detienne (1997) dice que a pesar que se piensa en naturalidad y faciliddad de mapeo entre entidades de un dominio de problema, los estudios demuestran lo contrario.
Los novices tienen que desarrollar un modelos procedimental antes de diseñar correctamente clases y objetos.
Rist(1996) OOP no es diferente pero es MAS.
Wiedenbeck(1999) tiene resultados de un experimentos de un grupo que se le enseño a programar en OOP y otro en procedimiental.
Para problemas cortos, los de OOP tuvieron mejores resultados. Pero para problemas largos y más complejos, los de procedimiental
tuvieron mejores resultados. Esto debido a que los flujos en OOP son mas distribuidos y eso hace más dificil que un novice haga
un modelo mental. Esto en parte a que OOP tiene una mayor curva de aprendizaje  y porque los programas OOP son más largos.
_Burkhardt, Detienne y Wiedenbeck (1997)_ proponen una teoria de OOP comprenhension dentro del cual mucho de los factores pueden ser analizados.
