# Learning and Teaching Programming:A review discussion

Robins, J Rountree, N Rountree
2003

## Libros con estudios anteriores:
* Sackman, 1970 -> Intro
* Weinberg, 1971-> Intro
* Soloway & Spohrer, 1989 -> enfocado en el novice programmer
* Hoc, Green, Samurcay, Gillmore, 1990

## Estado del arte

### Computer knowledge vs Programming strategies

Davis (1993) distingue entre programming knowledge (como funciona un loop) y programming strategies (como el loop es utilizado y aplicado apropiadamente en un programa).

Widowski and Eyferth (1986) proponen diversos métodos como un programador lee un programa. Expertos leen programas convencionales utilizando una estrategia top-down y programas no convencionales en cortos runs (bottom-up). Novices lo leen los dos tipos de programa de la misma manera.

### Comprehension and generation

Estudios sobre comprehension y sobre generation. Comprenhension es cómo se demuestra cómo funciona un programa y generation donde los sujetos tiene que crear una parte o todo el programa para resolver un problema.

#### Comprehension
Brooks (1977, 1983): un problema es representado como valores y estructuras (dominio intermedio) y luego instancia en algoritmos y estructuras de datos (programming domain).
Programas es formar mapeos entre dominios.
Este proceso es top-down y hipothesis driven

#### Generation
Rist(1995)
El conocimiento esta estructurado en nodos  en la memoria interna (working, episodic y semantic) o externa que son mas la especificación del programa, notas anteriores o el programa en si mismo).
Un search cue inicia la busqueda del nodo y se obtiene de la memoria y este nodo da lugar a otros nodos (muchas veces con otros search cues relacionados). Un sistema lineado de nodos que llevan a un resultado (output) es un plan.
Expertos obtienen los planes de la memoria y luego los implementan de forma lineal mientras que novices tienen que crear los planes.
Rist denota que un proceso realista de diseño envuelve la interacción  entre la busqueda de la estrategia y el diseño oportunista, la creación y obtención de un plan dada las limitaciones de la working memory y la estructura de la especificación del programa.
habla de working memory “parsing-ginsarp” de Green, Bellamy & Parker (1987)

### Procedural vs Object Oriented
